import numpy as np
import matplotlib.pyplot as plt
import sys
from matplotlib.animation import FuncAnimation

try:
    import petsc4py
    petsc4py.init(sys.argv)
    from petsc4py import PETSc
except ModuleNotFoundError:
    print("petsc4py not found")
    sys.exit()

import pflare   

'''
1D Viscous Burgers Equation - Top Hat IC
u_t + u u_x = nu * u_xx

Implicit Backward Euler
Advection: Upwind discretization
Diffusion: Central Difference
Newton nonlinear solver (SNES)
GMRES + AIR preconditioner (PFLARE)
'''

# --------------------------------------------------
# Parameters
# --------------------------------------------------
n = 300
dx = 1.0 / (n - 1)
dt = 0.005
nt = 300
nu = 0.001
tol_newton = 1e-10

# --------------------------------------------------
# DMDA grid
# --------------------------------------------------
da = PETSc.DMDA().create(
    sizes=[n],
    dof=1,
    stencil_width=1,
    boundary_type=PETSc.DM.BoundaryType.NONE
)
da.setUniformCoordinates(0.0, 1.0)

# --------------------------------------------------
# Vectors & Matrix
# --------------------------------------------------
u = da.createGlobalVec()
u_prev = da.createGlobalVec()
local_u = da.createLocalVec()

J = da.createMatrix()

# --------------------------------------------------
# Initial condition (Top Hat)
# --------------------------------------------------
(xs, xe) = da.getRanges()[0]
with da.getVecArray(u) as arr:
    for i in range(xs, xe):
        x_loc = i * dx
        if 0.1 <= x_loc <= 0.4:
            arr[i] = 1.0
        else:
            arr[i] = 0.0

# --------------------------------------------------
# Residual Function
# --------------------------------------------------
def formResidual(snes, x, f):
    da.globalToLocal(x, local_u)

    with da.getVecArray(local_u) as un, \
         da.getVecArray(u_prev) as uold, \
         da.getVecArray(f) as res:

        for i in range(xs, xe):
            if i == 0 or i == n - 1:
                res[i] = un[i] - 0.0
            else:
                ui = un[i]
                uim1 = un[i-1]
                uip1 = un[i+1]

                time_term = (ui - uold[i]) / dt
                convection_term = ui * (ui - uim1) / dx
                diffusion_term = nu * (uip1 - 2*ui + uim1) / (dx**2)

                res[i] = time_term + convection_term - diffusion_term

# --------------------------------------------------
# Jacobian Function
# --------------------------------------------------
def formJacobian(snes, x, J, P):
    P.zeroEntries()
    da.globalToLocal(x, local_u)

    row = PETSc.Mat.Stencil()
    col = PETSc.Mat.Stencil()

    with da.getVecArray(local_u) as un:
        for i in range(xs, xe):
            row.index = (i,)

            if i == 0 or i == n - 1:
                P.setValueStencil(row, row, 1.0)
            else:
                ui = un[i]
                uim1 = un[i-1]

                col.index = (i,)
                P.setValueStencil(
                    row, col,
                    (1.0/dt) + (2*ui - uim1)/dx + (2*nu)/(dx**2)
                )

                col.index = (i-1,)
                P.setValueStencil(
                    row, col,
                    (-ui/dx) - (nu)/(dx**2)
                )

                col.index = (i+1,)
                P.setValueStencil(
                    row, col,
                    -(nu)/(dx**2)
                )

    P.assemblyBegin()
    P.assemblyEnd()

    return PETSc.Mat.Structure.SAME_NONZERO_PATTERN

# --------------------------------------------------
# Solver Setup (SNES)
# --------------------------------------------------
snes = PETSc.SNES().create(comm=da.getComm())
snes.setFunction(formResidual, da.createGlobalVec())
snes.setJacobian(formJacobian, J)

ksp = snes.getKSP()
ksp.setType(PETSc.KSP.Type.GMRES)

pc = ksp.getPC()
pc.setType("air")     # <--- PFLARE AIR PRECONDITIONER

snes.setFromOptions()

# --------------------------------------------------
# Time Stepping Loop
# --------------------------------------------------
solution_history = []
solution_history.append(u.getArray().copy())

print(f"{'Step':<5} | {'Time':<6} | {'SNES Its':<8} | {'KSP Its':<8} | {'Res Norm':<10}")
print("-" * 55)

for step in range(1, nt + 1):

    u.copy(u_prev)
    snes.solve(None, u)

    snes_its = snes.getIterationNumber()
    ksp_its = snes.getLinearSolveIterations()
    res_norm = snes.getFunctionNorm()

    solution_history.append(u.getArray().copy())

    if step % 50 == 0 or step == 1:
        print(f"{step:<5d} | {step*dt:<6.3f} | {snes_its:<8d} | {ksp_its:<8d} | {res_norm:.2e}")

    if step == 50:
        print("\n" + "="*30)
        print(f" Jacobian Matrix A at Step {step}")
        print("="*30)
        J.view()
        print("="*30 + "\n")

# --------------------------------------------------
# Animation
# --------------------------------------------------
x_axis = np.linspace(0.0, 1.0, n)
fig, ax = plt.subplots(figsize=(7, 4))
line, = ax.plot(x_axis, solution_history[0], lw=2, color='crimson')

ax.set_xlim(0, 1)
ax.set_ylim(-0.1, 1.3)
ax.set_xlabel("x")
ax.set_ylabel("u")
ax.grid(True, alpha=0.3)

def update(frame):
    line.set_ydata(solution_history[frame])
    ax.set_title(f"Viscous Burgers Top Hat (nu={nu}) | t = {frame*dt:.3f}")
    return line,

ani = FuncAnimation(fig, update, frames=nt, interval=30, blit=True)
ani.save("burgers_tophat_air.gif", dpi=150)
plt.close()

print("\nAnimation saved as burgers_tophat_air.gif")
